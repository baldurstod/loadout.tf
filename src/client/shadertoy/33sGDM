#define PI4 		PI*.25
#define hash21(n)  	fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453)
#define rot(a) 		mat2(cos(a), -sin(a), sin(a), cos(a))

const int ITERATIONS = 12;
const float LINE_WIDTH = .01;
const float LINE_THRESHOLD = .25;
#define Q(p) p *= 2.*r(round(atan(p.x, p.y) * 4.) / 4.)
#define r(a) mat2(cos(a + asin(vec4(0,1,-1,0))))
#define time iTime
#define resolution iResolution.xy
float band (in vec2 id) {
    return step(hash21(id.xy), LINE_THRESHOLD);
}

// @author Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
vec2 hash12(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}

// @author Dave Hoskins
// https://www.shadertoy.com/view/4djSRW
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

float cube(vec3 p, vec3 s)
{
  p =abs(p) - s;
  return max(max(p.x,p.y),p.z);
}

float crosscube(vec3 p, vec3 s)
{
  vec3 a = vec3(s.x*1./3.,s.x*1./3.,s.x*4./3.);
  float d = cube(p,a.xyz);
  float d2 = cube(p,a.yzx);
  float d3 = cube(p,a.zxy);

  return min(min(d,d2),d3);
}

float menger(vec3 p, vec3 s)
{

  float d = cube(p,s);
  float td = crosscube(p,s);
  d = max(d,-td);

for(int i = 0; i < 4; i++)
{
  s *= 1./3.;
  float m = s.x * 2.;
  p = mod(p-m*0.5,m)-m*0.5;
  td = crosscube(p,s);
  d = max(d,-td);
}
  return d;
}

float map(vec3 p)
{

p.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));
p.yz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));
  float d = menger(p,vec3(1.));

  return d;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = (fragCoord.xy / iResolution.xy) - .5;
	float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;
	float si = sin(t);
	float co = cos(t);
	mat2 ma = mat2(co, si, -si, co);

	float v1, v2, v3;
	v1 = v2 = v3 = 0.0;
    vec2 p = (gl_FragCoord.xy * 2. - resolution.xy) / min(resolution.x,resolution.y);
	 vec2 auv = abs(uv);


  vec3 cp = vec3(0.,0.,3.);
  vec3 cd = vec3(0.,0.,-1.);
  vec3 cu = vec3(0.,1.,0.);
  vec3 cs = cross(cd,cu);
  float td = 1.;

  vec3 ray = normalize(p.x*cs+p.y*cu+cd*td);

  vec3 col3 = vec3(0.);
  float me = 0.;

  float d,t3 = 0.;
  vec3 rp = cp;
  for(int i = 0; i < 128; i++)
  {
      d = map(rp);
      me += exp(abs(d)*-1.2);
    if(d < 0.001)
    {
      break;
    }
    t3 += d;
    rp = cp + t3 * ray;
  }
 col3 = vec3(.3,.7,.9)*me*0.02;




    // the line width oscillates to add a perpetual motion
    float lw = LINE_WIDTH * (1.  + mod(t, .3) * clamp(1., -.5, .2) * .8);


    // a layer of lines
    vec2 divs = uv / lw;

    vec2 id = floor(divs);
    vec2 divs2 = uv / lw * .5;
    vec2 id2 = floor(divs);


    // slow animation of the bands
    // does it work on every machine ?

  ;

    float c = 0.0,
          a;

    vec2 s;

    // we iterate to create layers, and mask more or less
    for (int i = 0; i < ITERATIONS; i++) {
        float fi = mod(float(i) + floor(iTime * .1), float(ITERATIONS));
    	id.y = fi * 2.;
    	id2.y = fi * 2.;
      ;

        float l = max(band(id), band(id2));
        float mask = 0.0;



        // otherwise, mask will be a rectangme rotated n * PI/2

            float fa = floor(hash11(fi*10.2)*2.)
            		 	+ clamp(cos(iTime*0. + fi), -.2, .2) / .2
            			+ clamp(cos((iTime*0.+fi) * .5), -.1, .1) / .1;
		;
            vec2 center = hash12(fi*1.5) * .3 - .15;
            center.x+= cos(iTime*.0+fi) * .1 + cos(iTime*0.+fi) * .05 * .01;
            vec2 tuv = uv * rot(a);
            tuv.x+=cos(iTime*0.11)*3.;

            vec2 f = vec2(hash11(fi*2.) * .25 + .05);

            mask = s.x * s.y;


        c = mix(c, l, mask);
    }


    // periodic inversion synced to the strenching

    c = mix(c, (1.-c), step(.08, t) * round(cos(iTime) *.5+.5));


    // square
    c*= step(auv.x, .5);
    s = step(auv, vec2(.4));
    float inside = s.x*s.y;
    c*= inside;

    // background
    c+= clamp(pow((1.-length(uv)), .2)* 1.1, .2, 1.) * (1. - inside);
    c+= hash21(uv) * .1;

    // border
    s = step(auv, vec2(0.42));
    c-= s.x*s.y - inside;

    vec3 color = vec3(uv, c);

    color*= step(auv.x, .5);

	float s3 = 0.0;
	for (int i = 0; i < 90; i++)
	{
		vec3 p = s3 * vec3(uv, 0.0);

		p += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)*c+col3;
		for (int i = 0; i < 8; i++)	p = abs(p) / dot(p,p) - 0.659;
		v1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));
		v2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));
		v3 += length(p.xy*10.) * .0003;
		s3  += .035;
	}

	float len = length(uv);
	v1 *= smoothstep(.7, .0, len);
	v2 *= smoothstep(.5, .0, len);
	v3 *= smoothstep(.9, .0, len);

	vec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),
					(v1 + v3) * .3,
					 v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;

	fragColor=vec4(min(pow(abs(col)+col3, vec3(1.2)), 1.0), 1.0);
}
