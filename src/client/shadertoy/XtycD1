// Created by inigo quilez - iq/2008/2018
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.


// This is "Leizex", a procedural graphics I made in 2008, which was my 3rd ever
// raymarched image (I was still investigating and learning the technique).
//
// I just copy pasted the code, which run in C++ at the time, into GLSL and it pretty
// much worked out of the box! It's glad to see that after 10 years my code hasn't
// changed that much really, in cluding vaiable names!
//
// Link to the original piece: https://iquilezles.org/prods/index.htm#leizex


float hash( int n )
{
	n = (n << 13) ^ n;
    n = (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff;
    return float(n)/2147483647.0;
}


// value noise
float noise3f( in vec3 p, in int sem )
{
    ivec3 i = ivec3( floor(p) );
    vec3  f = p - vec3(i);

    // quintic smoothstep
    vec3 w = f*f*f*(f*(f*6.0-15.0)+10.0);

    int n = i.x + i.y * 57 + 113*i.z + sem;

	return 1.0 - 2.0*mix(mix(mix(hash(n+(0+57*0+113*0)),
                                 hash(n+(1+57*0+113*0)),w.x),
                             mix(hash(n+(0+57*1+113*0)),
                                 hash(n+(1+57*1+113*0)),w.x),w.y),
                         mix(mix(hash(n+(0+57*0+113*1)),
                                 hash(n+(1+57*0+113*1)),w.x),
                             mix(hash(n+(0+57*1+113*1)),
                                 hash(n+(1+57*1+113*1)),w.x),w.y),w.z);
}

float fbm( in vec3 p )
{
    return 0.5000*noise3f( p*1.0, 0 ) +
           0.2500*noise3f( p*2.0, 0 ) +
           0.1250*noise3f( p*4.0, 0 ) +
           0.0625*noise3f( p*8.0, 0 );
}

vec2 celular( in vec3 p )
{
    ivec3 q = ivec3( floor(p) );
    vec3  f = p - vec3(q);

	vec2 dmin = vec2( 2.0 );

	for( int k=-1; k<=1; k++ )
	for( int j=-1; j<=1; j++ )
	for( int i=-1; i<=1; i++ )
	{
		int nn = (q.x+i) + 57*(q.y+j) + 113*(q.z+k);
        vec3 di = vec3( float(i) + hash(nn     ),
		                float(j) + hash(nn+1217),
		                float(k) + hash(nn+2513) ) - f;
		float d2 = dot(di,di);

        if( d2<dmin.x )
        {
            dmin.y = dmin.x;
            dmin.x = d2;
        }
        else if( d2<dmin.y )
        {
            dmin.y = d2;
        }
	}

    return 0.25*sqrt(dmin);
}


float map( in vec3 pos, out float occ )
{
    pos.yz -= 1.0;

    vec3 dd = fract(1024.0+pos) - 0.5;
	float dis = length(dd) - 0.09;

	float disp = noise3f( 4.0*pos, 0 );
	dis += 0.8*disp;
	occ = clamp(-1.5*disp, 0.0, 1.0);

    if( dis<0.25 )
    {
	vec2 cel = celular( 16.0*pos );
	float disp2 = clamp(cel.y - cel.x, 0.0, 1.0);
	dis -= 1.0*disp2;
	occ *= clamp(disp2*12.0,0.0,1.0);
    }

    return dis;
}

#define ZERO (min(iFrame,0))

vec3 calcNormal( in vec3 pos )
{
    float kk;
    float eps = 0.0002;
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy, kk ) +
					  e.yyx*map( pos + e.yyx, kk ) +
					  e.yxy*map( pos + e.yxy, kk ) +
					  e.xxx*map( pos + e.xxx, kk ) );

#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 nor = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        nor += e*map(pos+eps*e, kk);
    }
    return normalize(nor);
#endif
}


float cast_ray( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out float matInfo )
{
    float t = mindist;
    for( int i=0; i<256; i++ )
    {
        vec3 p = ro + t*rd;
        float h = map( p, matInfo );
        if( abs(h)<(0.005*t) || t>maxdist ) break;
        t += h*0.1;
    }

    if( t>maxdist ) t=-1.0;

	return t;
}


float bump( in vec3 pos )
{
	return fbm( 256.0*pos );
}

vec3 addbump( in vec3 xnor, float bumpa, in vec3 pos)
{
    const float ke = 0.0005;

	float kk =        bump( pos );
    vec3 gra = vec3(  bump( pos+vec3(ke,0.0,0.0))-kk,
                      bump( pos+vec3(0.0,ke,0.0))-kk,
                      bump( pos+vec3(0.0,0.0,ke))-kk );

    return normalize(xnor + bumpa*gra);
}

const vec3 lig = vec3( 0.8, 0.5, -0.1 );
vec3 shade( in vec3 pos, in vec3 nor, in vec3 ro, in vec3 rd, float dis, in float occ )
{
    // material
    float f = 1.0 + 0.5*fbm(96.0*pos);
    vec3 mate = vec3(f);

    // bump
    vec3 xnor = addbump( nor, 1.0, 0.25*pos );

    // lighting
    vec3 rgb = vec3(0.0);
    rgb += mate*vec3(0.50,0.55,0.60)*occ;
    rgb += mate*vec3(0.6,0.5,0.3)*3.0*occ*clamp(dot( xnor, lig ), 0.0, 1.0);

    // fog extintion
	rgb /= (1.0+dis);
    // fog inscattering
	rgb += vec3(0.53,0.57,0.50)*2.0*(1.0 - exp2(-0.25*dis));

	return rgb;
}

vec3 colorCorrect( in vec3 rgb, in vec2 px )
{
    // grade
    rgb = clamp( (rgb-0.1)*vec3(1.5,1.7,1.5)*1.1, 0.0, 1.0 );

	// vigneting
    float v = px.x/iResolution.x;
	rgb *= 0.5 + 2.0*v*(1.0-v);

    return rgb;
}

// ===========================================================================

mat3 setCamera( in vec3 ro, in vec3 rt, in vec3 ru )
{
	vec3 cw = normalize(rt-ro);
	vec3 cu = normalize( cross(cw,ru) );
	vec3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, -cw );
}

void generateRay(out vec3 rayDir, out vec3 rayPos, in vec2 px )
{
    vec2 s = (-iResolution.xy+2.0*px)/iResolution.y;


    // barrel distort
	float r2 = s.x*s.x*0.32 + s.y*s.y;
	s *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);

    // set camera position and orientation
#if 0
         rayPos = vec3( -0.1564345, 1.0938345,  0.0123116 );
	vec3 rayTar = vec3( -0.0408938, 0.4444526,  1.0619653 );
	vec3 rayUp  = vec3(  0.0,       0.9999299, -0.0118397 );
#else
    float time = 0.5 + iTime*0.5;
    time = 0.5 - (iTime-10.0);

    vec3 rayTar = vec3( 0.0, 0.5, 1.0 );
	rayPos = rayTar - vec3(1.0,-0.75,1.0)*cos(6.2831853*time/20.0 + vec3(-1.5708,0.5,0.0));
	rayTar += 0.075*vec3(noise3f(vec3(2.0*iTime,0.0,0.5),0),
	                     noise3f(vec3(2.0*iTime,0.1,0.4),7),
	                     noise3f(vec3(2.0*iTime,0.2,0.3),9));
	float roll = 0.1*noise3f(vec3(2.0*time,0.0,0.0),13);
	vec3 rayUp = vec3( 0.0, cos(roll), sin(roll) );
#endif

    // compute camera matrix
    mat3 mat = setCamera( rayPos, rayTar, rayUp );

    // create ray direction
    rayDir = normalize( mat * vec3( -s.x, s.y, -1.0 ) );
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // genearete ray
    vec3 rd, ro; generateRay( rd, ro, fragCoord );

    // ray march scene
    vec3 col = vec3(0.0);

	float matInfo;
	float t = cast_ray( ro, rd, 0.01, 15.0, matInfo );
    if( t>0.0 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal(pos);
        col = shade( pos, nor, ro, rd, t, matInfo );
    }

    // color grade
	col = colorCorrect( col, fragCoord );

    fragColor = vec4(col,1.0);
}
